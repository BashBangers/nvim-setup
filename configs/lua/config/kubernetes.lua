-- ~/.config/nvim/lua/config/kubernetes.lua

-- kubectl.nvim: Cluster interaction (logs, exec, describe, port-forward, etc.)
-- NOTE: kubectl.nvim doesn't have built-in command filtering.
-- To block create/delete commands, we create a wrapper script and prepend it to PATH.

-- Blocked commands (modify this list as needed)
local BLOCKED_COMMANDS = {
	"create",
	"delete",
	-- "apply",  -- uncomment if you want to block apply too
	-- "patch",  -- uncomment if you want to block patch too
	-- "edit",   -- uncomment if you want to block edit too
}

-- Create a wrapper script that filters dangerous commands
local function create_kubectl_wrapper()
	local cache_dir = vim.fn.stdpath("cache")
	local bin_dir = cache_dir .. "/bin"
	local wrapper_path = bin_dir .. "/kubectl"
	
	-- Create bin directory if it doesn't exist
	local ok_mkdir = pcall(vim.fn.mkdir, bin_dir, "p")
	if not ok_mkdir then
		return nil, nil
	end
	
	-- Find the real kubectl (use 'command -v' to find it in PATH)
	local real_kubectl = ""
	local real_kubectl_cmd = "command -v kubectl 2>/dev/null"
	local kubectl_output = vim.fn.system(real_kubectl_cmd)
	local shell_error = vim.v.shell_error
	
	if kubectl_output and shell_error == 0 then
		real_kubectl = kubectl_output:gsub("%s+", ""):gsub("\n", "")
	end
	
	-- If not found, try common locations
	if real_kubectl == "" then
		local common_paths = { "/usr/local/bin/kubectl", "/usr/bin/kubectl", "/opt/homebrew/bin/kubectl" }
		for _, path in ipairs(common_paths) do
			if vim.fn.executable(path) == 1 then
				real_kubectl = path
				break
			end
		end
	end
	
	-- Final fallback
	if real_kubectl == "" then
		real_kubectl = "kubectl" -- fallback to just 'kubectl' and hope it's in PATH
	end
	
	-- Escape the path for shell script
	local escaped_kubectl = real_kubectl:gsub('"', '\\"')
	local blocked_str = table.concat(BLOCKED_COMMANDS, "|")
	
	local wrapper_content = string.format([=[#!/bin/sh
# kubectl wrapper that blocks dangerous commands for kubectl.nvim
# Generated by ~/.config/nvim/lua/config/kubernetes.lua

REAL_KUBECTL="%s"
BLOCKED_COMMANDS="%s"

# Get the command (first argument)
CMD="$1"

# Check if command is blocked
for blocked in $(echo "$BLOCKED_COMMANDS" | tr '|' ' '); do
	if [ "$CMD" = "$blocked" ]; then
		echo "âŒ Error: 'kubectl $CMD' is blocked for safety." >&2
		echo "   Blocked commands: $BLOCKED_COMMANDS" >&2
		echo "   To modify, edit: ~/.config/nvim/lua/config/kubernetes.lua" >&2
		exit 1
	fi
done

# Execute the real kubectl command
exec "$REAL_KUBECTL" "$@"
]=], escaped_kubectl, blocked_str)
	
	-- Write wrapper script
	local file = io.open(wrapper_path, "w")
	if not file then
		return nil, nil
	end
	
	file:write(wrapper_content)
	file:close()
	
	-- Make it executable (ignore errors here)
	pcall(function()
		os.execute("chmod +x " .. vim.fn.shellescape(wrapper_path))
	end)
	
	return bin_dir, wrapper_path
end

-- Setup function for kubectl.nvim
local function setup_kubectl()
	local ok_kubectl, kubectl = pcall(require, "kubectl")
	if not ok_kubectl then
		return
	end
	
	-- Create the wrapper script
	local bin_dir, wrapper_path = create_kubectl_wrapper()
	
	-- Prepend wrapper directory to PATH so it's found before real kubectl
	if bin_dir and wrapper_path then
		-- Prepend to PATH so our wrapper is found first
		local current_path = vim.env.PATH or ""
		vim.env.PATH = bin_dir .. ":" .. current_path
		
		kubectl.setup({
			-- optional:
			-- default_namespace = "default",
			-- prefer_fzf = true,
		})
		
		vim.notify(
			"kubectl.nvim: Command filtering enabled. Blocked: " .. table.concat(BLOCKED_COMMANDS, ", "),
			vim.log.levels.INFO
		)
	else
		-- Fallback: setup without filtering if wrapper creation failed
		kubectl.setup({
			-- optional:
			-- default_namespace = "default",
			-- prefer_fzf = true,
		})
		vim.notify("kubectl.nvim: Warning - Could not create command filter wrapper", vim.log.levels.WARN)
	end
end

-- Setup function for kubernetes.nvim
local function setup_kubernetes()
	local ok_kubernetes, kubernetes = pcall(require, "kubernetes")
	if not ok_kubernetes then
		return
	end
	
	kubernetes.setup({
		enable_hover = true,
		enable_schema = true,
	})
end

-- Export setup functions
return {
	setup_kubectl = setup_kubectl,
	setup_kubernetes = setup_kubernetes,
}

